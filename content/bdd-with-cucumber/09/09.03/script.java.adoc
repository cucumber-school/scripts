=== Dependency Injection

A fundamental concept for organising your support code in a Cucumber-JVM project is dependency injection.

Dependency injection is how you access other objects from your step defintion classes. In particular, it allows you to share those objects between multiple step definition classes, so that if you've started to organise your step definitions into different classes, they can still access the same objects.

This gives you a similar capability as you get with the "World" in Ruby or JavaScript Cucumbers - you can inject an object to store context state through the life of a scenario, or to contain useful helper methods.

In this lesson we'll show you how to introduce dependency injection into your Cucumber-JVM project, and use a simple World object to share some state with a parameter type class.

==== Exclude `@todo` scenarios

When we refactor, we want to make sure our tests are all green. Since we have one scenario that's not currently finished, let's change our `RunWith` configuration to exclude any scenarios tagged as `@todo`:
shot::[1, "Add `tags = \"not @todo\"`"]

[source,java]
include::../code/java/01-only-run-tests-we-expect-to-pass/shouty/src/test/java/shouty/RunCucumberTest.java[lines=7..10]


Good, now when we run Cucumber we should expect to see everything pass. 
shot::[1, "Run Cucumber"]

==== Adding a World class

Let's start by trying to inject a `ShoutyWorld` class into the contructor of our `StepDefinitions` class. shot::[]

[source,java]
----
include::../code/java/02-introduce-world-class/shouty/src/test/java/shouty/StepDefinitions.java[lines=26]
    ...
include::../code/java/02-introduce-world-class/shouty/src/test/java/shouty/StepDefinitions.java[lines=30..32]
----

We don't have one yet, so we can let the IDE help us to create one. shot::[]

[source,java]
----
include::../code/java/02-introduce-world-class/shouty/src/test/java/shouty/support/ShoutyWorld.java[lines=1..4]
----

If we run Cucumber now, we'll see an error,shot::[] because we need to let Cucumber know which framework we want to use for Dependency Injection. You can choose your project's own DI framework here, or you can use Cucumber's own lightweight `picocontainer` framework. shot::[]

[source,xml]
----
include::../code/java/03-add-dependency-on-picocontainer/shouty/pom.xml[lines=49..54]
----

shot::[1, "Run mvn test - should be green"]. Great. Now we can start moving code onto the World.

==== Move Network onto World

In order to be able to access the same `Network` instance everywhere, let's move that field onto our new `ShoutyWorld`.

We can start by writing the code we want to have. Imagine we already had a `network` field on the World, and we could just set it here like this: shot::[]

[source,java]
----
include::../code/java/04-move-network-onto-the-world/shouty/src/test/java/shouty/StepDefinitions.java[lines=53..56]
----

We don't have that field on our World object yet, so let's create it. shot::[]
and we need to add the default range here too. shot::[]

[source,java]
----
include::../code/java/04-move-network-onto-the-world/shouty/src/test/java/shouty/support/ShoutyWorld.java[lines=1..8]
----

We should also use the same `network` in this step where we create a new `Person` instance: shot::[]

[source,java]
----
include::../code/java/04-move-network-onto-the-world/shouty/src/test/java/shouty/StepDefinitions.java[lines=58..61]
----

Now we can delete the old `network` field on the `StepDefintions class` shot::[].
[source,java]
----
include::../code/java/02-introduce-world-class/shouty/src/test/java/shouty/StepDefinitions.java[lines=25..26]
----

Let's check everything is still green. shot::[1, "run mvn test"]. Good.

==== Introduce person parameter type

Now that we have moved the `network` onto our shared `ShoutyWorld` object, we can create a custom parameter type for `Person`, as we demonstrated in Chapter 3.

In order to do that, we'll first need to make a couple of "pre-factoring" changes to our `Person` class.

First, we'll need the `Person` to be aware of (and expose) its own `name` so that, once we get handed it in our step definition, we can easily put it into our `people` Map for later retrieval.

Secondly, we'll need a way to be able to move the location of a `Person` after it's been created, since our step defintion will be passed an existing instance of a `Person` from the step definition.

Let's start by adding the `name` to `Person`. We can start at the outside by modifying the step definition to shot::[] take the name on the constructor, and shot::[] expose it via a getter. 

[source,java]
----
include::../code/java/05-add-name-property-to-person/shouty/src/test/java/shouty/StepDefinitions.java[lines=58..62]
----

We can shot::[] lean on the IDE to add the `name` as the first constructor parameter for `Person`, and to shot::[] create a stub of the `getName` method.

Next we need to actually shot::[] add the `name` field to the `Person` class, 

[source,java]
----
include::../code/java/05-add-name-property-to-person/shouty/src/main/java/shouty/Person.java[lines=6]
    ...
include::../code/java/05-add-name-property-to-person/shouty/src/main/java/shouty/Person.java[lines=10]
    ...
include::../code/java/05-add-name-property-to-person/shouty/src/main/java/shouty/Person.java[lines=13..14]
        ...
----

and shot::[] make it accessible via the `getName` method.

[source,java]
----
include::../code/java/05-add-name-property-to-person/shouty/src/main/java/shouty/Person.java[lines=45]
----

Great. We have a few unit tests we need to update with the new API shot::[] and then things should be passing again. shot::[]

Next let's add that `moveTo` method. This time, since we're adding some behaviour to the `Person` we'll shot::[] add a unit test for it first.

[source,java]
----
include::../code/java/06-introduce-person-moveto-method/shouty/src/test/java/shouty/PersonTest.java[lines=41..46]
----

TODO: finish the narrative
