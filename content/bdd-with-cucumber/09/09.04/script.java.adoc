include::./title.adoc[]

Now that we have our World in place, we can use it to encapsulate common code that we need to run from our step defintiions in order to automate our app.

We're going to start by creating a custom parameter type for `Person`, then we'll create a helper method on the World for shouting, which is something we do a lot in our step definitions.

==== Move other fields to World

Just like the `network`, we can also move the `people` and `messagesShoutedBy` fields from the `StepDefinition` class to the `World`. These fields contain state about the people and messages that have been active in a given scenario, so it's important that we can access that state from anywhere in our test automation code.


We'll start with the people hashmap shot::[1, "move people hashmap (fast)"], then do the shot::[1, "move messagesShoutedBy hashmap (fast)"] `messagesShoutedBy` hashmap. And now we can remove this empty `Before` hook. shot::[]

==== Introduce person parameter type

Now that we've moved these fields onto our shared `ShoutyWorld` object, we can create a custom parameter type for `Person`, as we demonstrated in Chapter 3.

Let's start at the step definition and write the code we wish we had.

[source,java]
----
include::../code/java/07-remove-before-hook/shouty/src/test/java/shouty/StepDefinitions.java[lines=47..51]
----

We won't be using just a `{word}` anymore shot::[], we'll use a `{person}` shot::[], and instead of receiving a plain `String` shot::[] we'll receive an instance of `Person`. Now we can use shot::[] this `Person` object in the body of our step, with no need to create them here, or store them in the `people` map. Our parameter type will take care of all of that!

[source,java]
----
include::../code/java/08-use-parameter-type-in-one-step-fails-/shouty/src/test/java/shouty/StepDefinitions.java[lines=47..50]
----

When we shot::[] run Cucumber now, it tells us we need to register a parameter type:

----
[ERROR] Errors: 
[ERROR]   Could not create a cucumber expression for '{person} is located at {int}'.
It appears you did not register a parameter type.
----

So let's start by creating a new class in the `support` directory with some boilerplate in it to register the `{person}` parameter type with Cucumber. shot::[]

[source,java]
----
include::../code/java/09-add-boilerplate-for-person-parameter-type/shouty/src/test/java/shouty/support/PersonParameterType.java[lines=1..11]
----

That should be enough to satisfy Cucumber that there's a `{person}` parameter type, but we shot::[] get these errors because it's returning `null` instead of a `Person` instance like we'd expect.

So let's return a valid `Person`. 

We're going to need the `ShoutyWorld` to be available shot::[] to us in this context so that we have access to the `network` and `people` fields. Luckily, the exact same Dependency Injection pattern works in ParameterType classes just the same way it does in a step definition class.

[source,java]
----
include::../code/java/10-inject-world-into-parameter-type-class/shouty/src/test/java/shouty/support/PersonParameterType.java[lines=6..11]
    ...
}
----

The parameter type should return an instance of Sean, which we store in the `people` hashmap for other steps to reference.

[source,java]
----
include::../code/java/11-return-a-person-from-parameter-type/shouty/src/test/java/shouty/support/PersonParameterType.java[lines=13..14]
include::../code/java/11-return-a-person-from-parameter-type/shouty/src/test/java/shouty/support/PersonParameterType.java[lines=18..21]
----

In fact, we want any subsequent steps in a scenario to also be able to use this parameter type, so we can check if an instance of a person with this name already exists, and just return that if it does.

[source,java]
----
include::../code/java/11-return-a-person-from-parameter-type/shouty/src/test/java/shouty/support/PersonParameterType.java[lines=13..21]
----

Cucumber will create a new instance of this `ShoutyWorld` class for every scenario that it runs, so we don't need to worry about state leaking between our scenarios, but we do want to use this mechanism to share state between the steps of a scenario.

Now when we run the tests shot::[] everything should work again.

Great! We've added our first parameter type. Now we want to use it everywhere we can. shot::[1, "Fast montage of changing all the steps to use {person}"]

==== Moving our `shout` helper to the World

The World isn't just for storing state. We can also use it to contain helper methods for common actions against the system that we want to be able to re-use across our steps.

The `shout` method that's already been extracted in our `StepDefinitions` class is a good candidate for this. If we look at it carefullly, we can see that it's exhibiting the code smell known as "feature envy": the method is basically all about manipulating the `messagesShoutedBy` hashmap, to keep a record of who has shouted what messages. It would make more sense to have this method on our World so that our step defintion code becomes simpler.

We can start by shot::[] duplicating the method, copying it to the World and making it public. The references shot::[] to `messagesShoutedBy` no longer need to go through the `world` as we are on the `world` now.

[source,java]
----
include::../code/java/13-move-shout-method-to-world/shouty/src/test/java/shouty/support/ShoutyWorld.java[lines=11]
    ...
include::../code/java/13-move-shout-method-to-world/shouty/src/test/java/shouty/support/ShoutyWorld.java[lines=17..26]
----

We can shot::[] replace all the usages of the local `shout` method with the new one, and then finally shot::[] delete the old method.
